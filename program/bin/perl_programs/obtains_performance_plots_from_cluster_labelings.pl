#!/usr/bin/perl

########################
### See documentation below, in section 'START INSTRUCTIONS TO RUN THIS PROGRAM'
########################

########################
### EXTERNAL DEPENDENCIES
########################
# R (Rscript)
# R script 'obtains_ROC_and_PR_curves_from_matrix_with_gold_standards.R' and its dependencies
# Perl
# Perl modules indicated below by 'use'
##########################

############################
#### Step 1 -- Define parameters, default modules, infiles, and other dependencies
############################

use LoadParameters::Parameters;
use ReformatPerlEntities::ObtainOutfileWOpath;
use PathsDefinition::PathsToInputs;
use ReformatNumbers::NAvalues;

### Change here the path to file 'obtains_ROC_and_PR_curves_from_matrix_with_gold_standards.R'
$PathToScriptForROCandPR = "./bin/r_programs/obtains_ROC_and_PR_curves_from_matrix_with_gold_standards.R";

$ThisProgramName = $0;
$ThisProgramName =~ s/\S+\///;

$CommentsForHelp = "
#####################################################################################
################### START INSTRUCTIONS TO RUN THIS PROGRAM ##########################
###
### Entering a -infile_list_infiles of cell cluster labeling results from methods like CIBERSORT, GSEA, GSVA, ORA, METANEIGHBOR, etc.
### and a -infile_gold_standards with reference cluster annotations, this script plots Receiver Operating Characteristic (ROC)
### and Precision / Sensitivity (PR) curves, and reports their Area Under the Curve (AUC)
###
### -------------------------------------------INPUTS----------------------------------------------
###
### [1]
### -infile_list_infiles is a list of outfiles from cell cluster labeling methods, dataset IDs, and infile types, like:
###
### #Outfile from cell cluster labeling method              Dataset ID    Colour_plot_line_HEX
### #----------------------------------------------------   -----------   ------------
### Infile_1*CIBERSORT_enrichment_scores.tsv                Unique_ID_1   E69F00
### Infile_2*GSEA.Pval.Unfiltered.pos.mLog.mat.tsv          Unique_ID_2   009E73
### Infile_3*GSVA_enrichment_scores.tsv                     Unique_ID_3   CC79A7
### Infile_4*ORA.Pval.Uncorrected.cutoff_pos.mLog.mat.tsv   Unique_ID_4   1E90FF
### Infile_5*MetaNeighborUS_AUROC.tsv                       Unique_ID_5   D55E00
###
### Note: column 'Colour_plot_line_HEX' must contain a colour in HEX code
###
### Each infile specified in -infile_list_infiles must be a matrice of clusters (rows) vs. cell types (columns), like:
###
### Cluster    B_CELLS  T_CELLS  HEPATOCYTE ...etc
### cluster_1  0.9      0.03     0.05
### cluster_2  0.01     0.9      0.9
### cluster_3  0.02     0.04     0.06
### ...etc
###
### Infile examples                                   Generated by script
### ------------------------------------------        ---------------------------------------
### a) *CIBERSORT_enrichment_scores.tsv               obtains_CIBERSORT_for_MatrixColumns.pl
### b) *GSEA.Pval.Unfiltered.pos.mLog.mat.tsv         obtains_GSEA_for_MatrixColumns.pl
### c) *GSVA_enrichment_scores.tsv                    obtains_GSVA_for_MatrixColumns.R
### d) *ORA.Pval.Uncorrected.cutoff_pos.mLog.mat.tsv  obtains_ORA_for_MatrixColumns.pl
### e) *MetaNeighborUS_AUROC.tsv                      obtains_METANEIGHBOR_for_MatrixColumns.R
###
###
### [2]
### -infile_gold_standards in format like:
###
### #Cluster    Cell type
### #--------   ---------
### cluster_1   HEPATOCYTE
### cluster_2   HEPATOCYTE
### cluster_3   T_CELLS
###
### ----------------------------------------MAIN OUTPUTS-------------------------------------------
###
### [1]
### *merged.tsv table with compiled scores from inputted method results and gold standards
###
### [2]
### PERFORMANCE_PLOTS/*.auc table with Area Under the Curve values
###
### [3]
### PERFORMANCE_PLOTS/*.pdf table with the ROC and PR curve plots
###
### ------------------------------------------COMMANDS---------------------------------------------
###
### $ThisProgramName [options]
###   -path_outfiles                  (path/name to the directory where outfiles will be saved)
###   -infile_list_infiles            (path/name to the list of infiles to process)
###   -infile_gold_standards          (path/name to the gold standards)
###   -use_graphics_device            (indicates if the type of outfile: 'pdf' or 'png
###                                    Or type 'NA' to get only the Area Under the Curve (AUC) values, without plots)
###
###   -print_plot_ticks_labels_legend (Indicates if plots should contain:
###                                    a) axes labels, tick marks and legends (type 'all')
###                                    b) only tick marks (type 'ticks')
###                                    c) no axes labels, tick marks or legends (type 'none')
###                                    d) if using '-use_graphics_device NA', type 'NA'
###
###   -cex_labels                     (Indicates a factor to decrease/increase the size of labels
###                                    For example, to use labels 1.5 times bigger than normal use '-print_plot_ticks_labels_legend 1.5',
###                                    or to use labels half size than usual use '-print_plot_ticks_labels_legend 0.5'
###                                    only applies if using '-print_plot_ticks_labels_legend all')
###
###   -lwd                            (Indicates a factor to decrease/increase the lines width
###                                    For example, to use lines 1.5 times ticker than normal use '-lwd 1.5',
###                                    or to use lines thinner than usual use '-lwd 0.5')
###
##################### END INSTRUCTIONS TO RUN THIS PROGRAM ##########################
#####################################################################################";
$CommentsForHelp =~ s/(\n####)|(\n###)|(\n##)|(\n#)/\n/g;

&Readme;
&Parameters;

############################
#### Step 2 -- Loading data
############################

### Load cluster labeling results

$infile_list = $hashParameters{infile_list_infiles};
$infile_list =~ s/~\//\/$Users_home\/$DefaultUserName\//;

if ($infile_list =~ /\.bz2$/) {
open (INFILE_LIST, "bzip2 -qdc $infile_list |") or die "Can't open '$infile_list' (expected bzipped infile_list)\n";
}elsif ($infile_list =~ /\.gz$/) {
open (INFILE_LIST, "gzip -qdc $infile_list |") or die "Can't open '$infile_list' (expected gzipped infile_list)\n";
}else{
open (INFILE_LIST, "<$infile_list") or die "Can't open '$infile_list' (expected unzipped infile_list)\n";
}

$countDatasets   = 0;
while ($line = <INFILE_LIST>) {
chomp $line;

	unless ($line =~ /^#/) {
		if ($line =~ /^(\S+)(\s+)(\S+)(\s+)(\S+)$/) {
		$infile_clust_labels   = $1;
		$DatasetID             = $3;
		$colour_hex            = $5;
		$infile_clust_labels   =~ s/~\//\/$Users_home\/$DefaultUserName\//;
		$colour_hex            =~ s/^\s+//;
		$colour_hex            =~ s/^#//;
		$countDatasets++;

			if ($colour_hex =~ /\S/) {
				unless ($colour_hex =~ /^\S\S\S\S\S\S$/) {
				die "\n\nERROR!!! unexpected format in colour HEX:\n'$colour_hex'\n\n";
				}
			$colour_hex = "#$colour_hex";
			}
		
		}else{
		die "\n\nERROR!!! unexpected format in line:\n'$line'\n\n";
		}
		
		if ($hashAllDatasetIDs{$DatasetID}) {
		die "\n\nERROR!!! 'unique_flag_dataset' strings must be unique, but '$DatasetID' appears more than once in -infile_list_infiles\n\n";
		}else{
		$hashAllOrderedDatasets{$countDatasets} = $DatasetID;
		$hashAllDatasetIDs{$DatasetID} = 1;
		$hashNumberOfDatasetToColour{$countDatasets} = $colour_hex;
		}
	
		if (-f $infile_clust_labels) {
		&LoadPredictions($infile_clust_labels,$DatasetID);
		}else{
		die "\n\nERROR!!! couldn't find '$infile_clust_labels'\n\n";
		}
	}
}
close INFILE_LIST;


## Load gold standards

$infile_gold_standards = $hashParameters{infile_gold_standards};
$infile_gold_standards =~ s/~\//\/$Users_home\/$DefaultUserName\//;
&LoadGoldStandards($infile_gold_standards,$DatasetID);


############################
#### Step 3 -- Generate merged table outfile for R
############################

open OUTFILE, ">$hashParameters{path_outfiles}/$outfileWOpath.merged.tsv" or die "Can't open '$hashParameters{path_outfiles}/$outfileWOpath.merged.tsv'\n";

print OUTFILE "ClusterId_ClassId\tLabel";
$hashAllOrderedDatasets{$countDatasets} = $DatasetID;

foreach $NumberOfDataset (1..$countDatasets) {
$DatasetID = $hashAllOrderedDatasets{$NumberOfDataset};
print OUTFILE "\t$DatasetID";
}
print OUTFILE "\n";

foreach $clusterid (sort keys %hashAllClusterIds) {
	foreach $classid (sort keys %hashAllClasses) {
		
		if ($hashGoldStandards{$clusterid} eq $classid) {
		$Label = 1;
		}else{
		$Label = 0;
		}
		print OUTFILE "$clusterid.vs.$classid\t$Label";

		foreach $NumberOfDataset (1..$countDatasets) {
		$DatasetID = $hashAllOrderedDatasets{$NumberOfDataset};
		
			if ($hashAllScoresPerDataset{$DatasetID}{$clusterid}{$classid}) {
			$score = $hashAllScoresPerDataset{$DatasetID}{$clusterid}{$classid};
			$score =~ s/^_//;
			}else{
			$score = "NA";
			}
		print OUTFILE "\t$score";
		}
		print OUTFILE "\n";
	}
}
close OUTFILE;

############################
#### Step 4 -- Generate colours table for R (optional)
############################

if ($hashParameters{use_graphics_device} =~ /^NA$/i) {
$InfileColours = " NA";
}else{

$InfileColours = " $hashParameters{path_outfiles}/$outfileWOpath.colours.tsv";

open (COLOURS, ">$hashParameters{path_outfiles}/$outfileWOpath.colours.tsv") or die "Can't open '$hashParameters{path_outfiles}/$outfileWOpath.colours.tsv'\n";

	foreach $NumberOfDataset (1..$countDatasets) {
	$DatasetID = $hashAllOrderedDatasets{$NumberOfDataset};
	print COLOURS "$DatasetID" . "\t" . "$hashNumberOfDatasetToColour{$NumberOfDataset}\n";
	}
close COLOURS;
}


############################
#### Step 5 -- Generate plots
############################

$ins = "Rscript $PathToScriptForROCandPR -i $hashParameters{path_outfiles}/$outfileWOpath.merged.tsv -o $hashParameters{path_outfiles}/PERFORMANCE_PLOTS -p $outfileWOpath -d $hashParameters{use_graphics_device} -l $hashParameters{lwd} -c $InfileColours -w $hashParameters{print_plot_ticks_labels_legend} -x $hashParameters{cex_labels}";
system "$ins";

&PrintParameters;

print "\n\n  Done!!!\n  Check '$hashParameters{path_outfiles}/$outfileWOpath.*' for outfiles\n\n";

exit;

########################################################
################ END OF PROGRAM ########################
########################################################


########################################################
################ START SUBROUTINES #####################
########################################################


##>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sub Parameters {

########## Print "Usage" for user

print "$CommentsForHelp\n\n";

##########################
######## Options and Infiles

use Cwd 'abs_path';
$ScriptName = abs_path($0);
$Parameters .= "$ScriptName\n";

chomp @ARGV;
@arrayInputtedOneLineCommands = @ARGV;

%hashParametersTolookFor = (
'path_outfiles' => 1,
'infile_list_infiles' => 1,
'infile_gold_standards' => 1,
'use_graphics_device' => 1,
'print_plot_ticks_labels_legend' => 1,
#'cex_labels' => 1,
'lwd' => 1,
);

#######################
#### Starts -- Evaluate parameters

&LoadParameters::Parameters::MainSubParameters(\%hashParametersTolookFor,\@arrayInputtedOneLineCommands);
$Parameters .= "$MoreParameters";

## Defining prefix string for OUTFILE
ReformatPerlEntities::ObtainOutfileWOpath::ObtainOutfileWOpath($hashParameters{infile_list_infiles});

#### Ends -- Evaluate parameters
#######################

}
##<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sub PrintParameters {

### Printing out parameters. Need to be concatenated at sub(Parameters)
open PARAMETERS, ">$hashParameters{path_outfiles}/$outfileWOpath.PlotClusterLabelingPerformance.Parameters" or die "Can't open '$hashParameters{path_outfiles}/$outfileWOpath.PlotClusterLabelingPerformance.Parameters'\n";
print PARAMETERS "$Parameters";
close PARAMETERS;
}
##<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sub Readme {

#my ($date) = `date`;
#chomp $date;

$Parameters .= "
#################################################################
# Javier Diaz -- $date
# javier.diazmejia\@gmail.com
#################################################################\n
$Extras
#################################################################
######################### PARAMETERS ############################
#################################################################\n\n";

}
##<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sub LoadPredictions {

($infile,$DatasetID) = @_;

print "Loading '$DatasetID' dataset from:\n$infile\n";

open (INFILE, "<$infile") or die "Can't open '$infile' infile by LoadPredictions\n";

$countRows = 0;
while ($line = <INFILE>) {
chomp $line;
$c = 0;
	unless ($line =~ /^#/) {
	$countRows++;
		if ($countRows == 1) {
		@ColumnsHeaders = split ("\t", $line);
		$cMinusOne = -1;
			foreach $columnheader (@ColumnsHeaders) {
			$columnheader =~ s/ /_/g;
			$cMinusOne++;
				unless ($cMinusOne == 0) {
				$hashColumnNumbersMinusOne{$DatasetID}{$cMinusOne} = $columnheader;
				}
			}
		}else{
		@Data = split ("\t", $line);
		$cMinusOne = -1;
		$clusterid = @Data[0];
		
			foreach $es (@Data) {
			$cMinusOne++;
				unless ($cMinusOne == 0) {
				$classid   = $hashColumnNumbersMinusOne{$DatasetID}{$cMinusOne};
				$hashAllScoresPerDataset{$DatasetID}{$clusterid}{$classid} = "_$es";
				$hashAllClusterIds{$clusterid} = 1;
				$hashAllClasses{$classid} = 1;
				}
			}
		}
	}
}
close INFILE;

}

##<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sub LoadGoldStandards {

($infile) = @_;

print "Loading gold standards from:\n$infile\n";

open (INFILE, "<$infile") or die "Can't open '$infile' infile by LoadGoldStandards\n";

while ($line = <INFILE>) {
chomp $line;
	unless ($line =~ /^#/) {
		if ($line =~ /^(\S+)(\s+)(\S+)/) {
		$clusterid = $1;
		$classid   = $3;
		$hashGoldStandards{$clusterid} = $classid;
		}
	}
}
close INFILE;

}

##<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
